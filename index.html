<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Snake Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #0a0a0f;
            color: #00ffaa;
            overflow: hidden;
            height: 100vh;
        }
        
        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .score-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0, 255, 170, 0.1) 0%, rgba(0, 100, 80, 0.3) 100%);
            border: 1px solid #00ffaa;
            border-radius: 10px;
            padding: 15px 25px;
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.3), inset 0 0 20px rgba(0, 255, 170, 0.1);
        }
        
        .score-label {
            font-size: 12px;
            color: #00cc88;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .score-value {
            font-size: 36px;
            font-weight: 900;
            text-shadow: 0 0 10px #00ffaa, 0 0 20px #00ffaa;
        }
        
        .controls-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 15px;
            font-size: 11px;
            color: #666;
        }
        
        .controls-panel kbd {
            background: #222;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 2px 6px;
            color: #00ffaa;
            margin: 0 2px;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff3366;
            border-radius: 20px;
            padding: 40px 60px;
            box-shadow: 0 0 50px rgba(255, 51, 102, 0.5);
            display: none;
        }
        
        .game-over h2 {
            font-size: 48px;
            color: #ff3366;
            text-shadow: 0 0 20px #ff3366;
            margin-bottom: 20px;
        }
        
        .game-over p {
            font-size: 18px;
            color: #fff;
            margin-bottom: 30px;
        }
        
        .restart-btn {
            background: linear-gradient(135deg, #00ffaa 0%, #00cc88 100%);
            border: none;
            padding: 15px 40px;
            font-family: 'Orbitron', monospace;
            font-size: 16px;
            font-weight: 700;
            color: #0a0a0f;
            border-radius: 30px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px #00ffaa;
        }
        
        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffaa;
            border-radius: 20px;
            padding: 40px 60px;
            box-shadow: 0 0 50px rgba(0, 255, 170, 0.3);
        }
        
        .start-screen h1 {
            font-size: 42px;
            color: #00ffaa;
            text-shadow: 0 0 20px #00ffaa;
            margin-bottom: 20px;
        }
        
        .start-screen p {
            font-size: 14px;
            color: #888;
            margin-bottom: 30px;
            line-height: 1.8;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div class="score-panel">
                <div class="score-label">Score</div>
                <div class="score-value" id="score">0</div>
            </div>
            
            <div class="controls-panel">
                <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move X/Z &nbsp;
                <kbd>Q</kbd><kbd>E</kbd> Move Y &nbsp;
                <kbd>Space</kbd> Pause
            </div>
            
            <div class="start-screen" id="start-screen">
                <h1>3D SNAKE</h1>
                <p>Navigate in 3D space!<br>
                <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> for X/Z axes<br>
                <kbd>Q</kbd> down | <kbd>E</kbd> up</p>
                <button class="restart-btn" onclick="startGame()">START GAME</button>
            </div>
            
            <div class="game-over" id="game-over">
                <h2>GAME OVER</h2>
                <p>Final Score: <span id="final-score">0</span></p>
                <button class="restart-btn" onclick="restartGame()">PLAY AGAIN</button>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        const GRID_SIZE = 15;
        const CELL_SIZE = 2;
        
        let scene, camera, renderer, controls;
        let snake = [];
        let snakeRotations = []; // 存储每个蛇身的旋转角度
        let food = null;
        let direction = { x: 1, y: 0, z: 0 };
        let nextDirection = { x: 1, y: 0, z: 0 };
        let score = 0;
        let gameRunning = false;
        let gamePaused = false;
        let lastMoveTime = 0;
        const moveInterval = 300;
        
        const snakeMeshes = [];
        const gridHelper = [];
        let foodMesh = null;
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);
            scene.fog = new THREE.Fog(0x0a0a0f, 30, 80);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(40, 35, 40);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 100;
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00ffaa, 1, 100);
            pointLight.position.set(0, 30, 0);
            scene.add(pointLight);
            
            const pointLight2 = new THREE.PointLight(0xff3366, 0.5, 100);
            pointLight2.position.set(30, 20, 30);
            scene.add(pointLight2);
            
            createGrid();
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            animate();
        }
        
        function createGrid() {
            const gridGroup = new THREE.Group();
            const gridMaterial = new THREE.LineBasicMaterial({ color: 0x1a1a2e, transparent: true, opacity: 0.5 });
            
            const halfSize = GRID_SIZE * CELL_SIZE / 2;
            
            for (let i = 0; i <= GRID_SIZE; i++) {
                const points1 = [
                    new THREE.Vector3(i * CELL_SIZE - halfSize, -halfSize, -halfSize),
                    new THREE.Vector3(i * CELL_SIZE - halfSize, -halfSize, halfSize)
                ];
                const geometry1 = new THREE.BufferGeometry().setFromPoints(points1);
                const line1 = new THREE.Line(geometry1, gridMaterial);
                gridGroup.add(line1);
                
                const points2 = [
                    new THREE.Vector3(-halfSize, -halfSize, i * CELL_SIZE - halfSize),
                    new THREE.Vector3(halfSize, -halfSize, i * CELL_SIZE - halfSize)
                ];
                const geometry2 = new THREE.BufferGeometry().setFromPoints(points2);
                const line2 = new THREE.Line(geometry2, gridMaterial);
                gridGroup.add(line2);
                
                const points3 = [
                    new THREE.Vector3(-halfSize, i * CELL_SIZE - halfSize, -halfSize),
                    new THREE.Vector3(halfSize, i * CELL_SIZE - halfSize, -halfSize)
                ];
                const geometry3 = new THREE.BufferGeometry().setFromPoints(points3);
                const line3 = new THREE.Line(geometry3, gridMaterial);
                gridGroup.add(line3);
            }
            
            scene.add(gridGroup);
            
            const borderGeometry = new THREE.BoxGeometry(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
            const borderMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.15 
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            scene.add(border);
        }
        
        function createSnakeSegment(position, isHead = false) {
            const geometry = new THREE.BoxGeometry(CELL_SIZE * 0.7, CELL_SIZE * 0.7, CELL_SIZE * 0.7);
            const material = new THREE.MeshStandardMaterial({
                color: isHead ? 0x00ffaa : 0x00cc88,
                emissive: isHead ? 0x00ffaa : 0x004433,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.4
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            
            if (isHead) {
                const glowGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.85, CELL_SIZE * 0.85, CELL_SIZE * 0.85);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffaa,
                    transparent: true,
                    opacity: 0.25
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                mesh.add(glow);
            }
            
            scene.add(mesh);
            return mesh;
        }
        
        function createFood(position) {
            const geometry = new THREE.OctahedronGeometry(CELL_SIZE * 0.4);
            const material = new THREE.MeshStandardMaterial({
                color: 0xff3366,
                emissive: 0xff3366,
                emissiveIntensity: 0.8,
                metalness: 0.5,
                roughness: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            
            const glowGeometry = new THREE.OctahedronGeometry(CELL_SIZE * 0.6);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff3366,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            mesh.add(glow);
            
            scene.add(mesh);
            return mesh;
        }
        
        function getRandomPosition() {
            const halfSize = (GRID_SIZE - 1) / 2;
            let position;
            let attempts = 0;
            const maxAttempts = 200;
            
            // 收集所有空位
            const emptyPositions = [];
            for (let x = -halfSize; x <= halfSize; x++) {
                for (let y = -halfSize; y <= halfSize; y++) {
                    for (let z = -halfSize; z <= halfSize; z++) {
                        const testPos = new THREE.Vector3(x, y, z).multiplyScalar(CELL_SIZE);
                        if (!isPositionOccupied(testPos)) {
                            emptyPositions.push(testPos);
                        }
                    }
                }
            }
            
            if (emptyPositions.length > 0) {
                return emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
            }
            
            // 如果没有空位，随机返回一个（游戏会结束）
            return new THREE.Vector3(
                Math.floor(Math.random() * GRID_SIZE) - halfSize,
                Math.floor(Math.random() * GRID_SIZE) - halfSize,
                Math.floor(Math.random() * GRID_SIZE) - halfSize
            ).multiplyScalar(CELL_SIZE);
        }
        
        function isPositionOccupied(position) {
            for (const segment of snake) {
                if (segment.position.distanceTo(position) < CELL_SIZE * 0.5) {
                    return true;
                }
            }
            return false;
        }
        
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            resetGame();
            gameRunning = true;
            lastMoveTime = performance.now();
        }
        
        function restartGame() {
            document.getElementById('game-over').style.display = 'none';
            resetGame();
            gameRunning = true;
            lastMoveTime = performance.now();
        }
        
        function resetGame() {
            snake.forEach(seg => scene.remove(seg.mesh));
            snake = [];
            snakeRotations = [];
            
            if (foodMesh) {
                scene.remove(foodMesh);
                foodMesh = null;
            }
            
            const halfSize = (GRID_SIZE - 1) / 2;
            const startPos = new THREE.Vector3(0, 0, 0).multiplyScalar(CELL_SIZE);
            
            snake.push({ position: startPos.clone(), mesh: createSnakeSegment(startPos, true) });
            snakeRotations.push({ x: 0, y: 0 });
            
            direction = { x: 1, y: 0, z: 0 };
            nextDirection = { x: 1, y: 0, z: 0 };
            score = 0;
            updateScore();
            
            spawnFood();
        }
        
        function spawnFood() {
            if (foodMesh) {
                scene.remove(foodMesh);
            }
            
            const position = getRandomPosition();
            foodMesh = createFood(position);
        }
        
        function updateScore() {
            document.getElementById('score').textContent = score;
        }
        
        function moveSnake() {
            direction = { ...nextDirection };
            
            const head = snake[0];
            const newPosition = head.position.clone();
            newPosition.x += direction.x * CELL_SIZE;
            newPosition.y += direction.y * CELL_SIZE;
            newPosition.z += direction.z * CELL_SIZE;
            
            const halfSize = (GRID_SIZE * CELL_SIZE) / 2;
            
            if (Math.abs(newPosition.x) > halfSize || 
                Math.abs(newPosition.y) > halfSize || 
                Math.abs(newPosition.z) > halfSize) {
                gameOver();
                return;
            }
            
            for (let i = 1; i < snake.length; i++) {
                if (snake[i].position.distanceTo(newPosition) < CELL_SIZE * 0.5) {
                    gameOver();
                    return;
                }
            }
            
            const isHead = true;
            const newMesh = createSnakeSegment(newPosition, isHead);
            newMesh.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            if (snake[0].mesh.children.length > 0) {
                snake[0].mesh.children[0].removeFromParent();
            }
            snake[0].mesh.material.color.setHex(0x00cc88);
            snake[0].mesh.material.emissive.setHex(0x004433);
            
            snake.unshift({ position: newPosition, mesh: newMesh });
            
            if (foodMesh && newPosition.distanceTo(foodMesh.position) < CELL_SIZE * 0.8) {
                scene.remove(foodMesh);
                foodMesh = null;
                score += 10;
                updateScore();
                spawnFood();
            } else {
                const tail = snake.pop();
                scene.remove(tail.mesh);
            }
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
        }
        
        function onKeyDown(event) {
            if (!gameRunning || gamePaused) {
                if (event.code === 'Space') {
                    gamePaused = !gamePaused;
                    event.preventDefault();
                }
                return;
            }
            
            switch(event.code) {
                case 'KeyW':
                    if (direction.z !== 1) nextDirection = { x: 0, y: 0, z: -1 };
                    break;
                case 'KeyS':
                    if (direction.z !== -1) nextDirection = { x: 0, y: 0, z: 1 };
                    break;
                case 'KeyA':
                    if (direction.x !== 1) nextDirection = { x: -1, y: 0, z: 0 };
                    break;
                case 'KeyD':
                    if (direction.x !== -1) nextDirection = { x: 1, y: 0, z: 0 };
                    break;
                case 'KeyQ':
                    if (direction.y !== 1) nextDirection = { x: 0, y: -1, z: 0 };
                    break;
                case 'KeyE':
                    if (direction.y !== -1) nextDirection = { x: 0, y: 1, z: 0 };
                    break;
                case 'Space':
                    gamePaused = !gamePaused;
                    event.preventDefault();
                    break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            controls.update();
            
            if (foodMesh) {
                foodMesh.rotation.y += 0.02;
                foodMesh.rotation.x += 0.01;
                const scale = 1 + Math.sin(currentTime * 0.005) * 0.1;
                foodMesh.scale.set(scale, scale, scale);
            }
            
            // 旋转所有蛇身片段，使其始终可见
            snake.forEach((seg, index) => {
                const rotationSpeed = 0.02 + index * 0.005;
                seg.mesh.rotation.x += rotationSpeed;
                seg.mesh.rotation.y += rotationSpeed * 0.7;
            });
            
            if (gameRunning && !gamePaused && currentTime - lastMoveTime > moveInterval) {
                moveSnake();
                lastMoveTime = currentTime;
            }
            
            renderer.render(scene, camera);
        }
        
        init();
        
        window.startGame = startGame;
        window.restartGame = restartGame;
    </script>
</body>
</html>
