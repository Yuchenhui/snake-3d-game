<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Snake Game</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    overflow: hidden;
    background: #0a0a0f;
    font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
    color: #fff;
  }
  canvas { display: block; }

  #hud {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 30px;
    z-index: 10;
    pointer-events: none;
  }
  .hud-item {
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(0, 255, 255, 0.3);
    border-radius: 8px;
    padding: 8px 20px;
    text-align: center;
    backdrop-filter: blur(10px);
  }
  .hud-label {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: rgba(0, 255, 255, 0.6);
  }
  .hud-value {
    font-size: 28px;
    font-weight: bold;
    color: #0ff;
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
  }

  #controls-hint {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 10px 24px;
    z-index: 10;
    pointer-events: none;
    backdrop-filter: blur(10px);
    display: flex;
    gap: 20px;
    font-size: 13px;
    color: rgba(255, 255, 255, 0.5);
  }
  .key {
    display: inline-block;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    padding: 1px 7px;
    font-weight: bold;
    color: #fff;
    font-size: 12px;
  }

  #overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 20;
    backdrop-filter: blur(5px);
  }
  #overlay.hidden { display: none; }
  .overlay-box {
    text-align: center;
    background: rgba(10, 10, 20, 0.95);
    border: 1px solid rgba(0, 255, 255, 0.3);
    border-radius: 16px;
    padding: 40px 60px;
    box-shadow: 0 0 40px rgba(0, 255, 255, 0.1);
  }
  .overlay-box h1 {
    font-size: 36px;
    margin-bottom: 10px;
    color: #0ff;
    text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
  }
  .overlay-box .subtitle {
    font-size: 16px;
    color: rgba(255, 255, 255, 0.5);
    margin-bottom: 24px;
  }
  .overlay-box .final-score {
    font-size: 48px;
    font-weight: bold;
    color: #f0f;
    text-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    margin-bottom: 8px;
  }
  .overlay-box .final-label {
    font-size: 14px;
    color: rgba(255, 255, 255, 0.4);
    margin-bottom: 24px;
  }
  .overlay-box .prompt {
    font-size: 14px;
    color: rgba(0, 255, 255, 0.7);
    animation: pulse 1.5s ease-in-out infinite;
  }
  @keyframes pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
  }
</style>
</head>
<body>

<div id="hud">
  <div class="hud-item">
    <div class="hud-label">Score</div>
    <div class="hud-value" id="score-display">0</div>
  </div>
  <div class="hud-item">
    <div class="hud-label">Length</div>
    <div class="hud-value" id="length-display">3</div>
  </div>
  <div class="hud-item">
    <div class="hud-label">Best</div>
    <div class="hud-value" id="best-display">0</div>
  </div>
</div>

<div id="controls-hint">
  <span><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> X/Z 移动</span>
  <span><span class="key">Q</span> 下降 <span class="key">E</span> 上升</span>
  <span><span class="key">Space</span> 开始/重启</span>
</div>

<div id="overlay">
  <div class="overlay-box" id="overlay-content">
    <h1>3D Snake</h1>
    <div class="subtitle">在 15×15×15 的立方体空间中生存</div>
    <div class="prompt">按 <span class="key">Space</span> 开始游戏</div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function() {
  'use strict';

  // --- Constants ---
  const GRID = 15;
  const HALF = Math.floor(GRID / 2); // 7
  const CELL = 1;
  const TICK_MS = 200;

  // --- State ---
  let snake = [];
  let direction = { x: 1, y: 0, z: 0 };
  let nextDirection = { x: 1, y: 0, z: 0 };
  let food = null;
  let score = 0;
  let best = parseInt(localStorage.getItem('snake3d_best') || '0', 10);
  let running = false;
  let gameOver = false;
  let lastTick = 0;

  // --- DOM ---
  const scoreEl = document.getElementById('score-display');
  const lengthEl = document.getElementById('length-display');
  const bestEl = document.getElementById('best-display');
  const overlay = document.getElementById('overlay');
  const overlayContent = document.getElementById('overlay-content');
  bestEl.textContent = best;

  // --- Three.js Setup ---
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a0a0f, 0.015);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
  camera.position.set(22, 18, 22);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x0a0a0f);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // --- Lights ---
  const ambientLight = new THREE.AmbientLight(0x222244, 0.5);
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.3);
  dirLight.position.set(10, 20, 10);
  scene.add(dirLight);

  const pointLight1 = new THREE.PointLight(0x00ffff, 0.8, 50);
  pointLight1.position.set(10, 10, 10);
  scene.add(pointLight1);

  const pointLight2 = new THREE.PointLight(0xff00ff, 0.5, 50);
  pointLight2.position.set(-10, -5, -10);
  scene.add(pointLight2);

  // --- Arena (wireframe box) ---
  const arenaSize = GRID * CELL;
  const arenaGeo = new THREE.BoxGeometry(arenaSize, arenaSize, arenaSize);
  const arenaEdges = new THREE.EdgesGeometry(arenaGeo);
  const arenaMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.15 });
  const arenaWire = new THREE.LineSegments(arenaEdges, arenaMat);
  scene.add(arenaWire);

  // Grid lines on each face
  const gridGroup = new THREE.Group();
  const gridMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.04 });
  function addGridPlane(axis1, axis2, fixedAxis, fixedVal) {
    for (let i = -HALF; i <= HALF; i++) {
      const points = [];
      const p1 = new THREE.Vector3();
      const p2 = new THREE.Vector3();
      p1[fixedAxis] = fixedVal;
      p2[fixedAxis] = fixedVal;
      p1[axis1] = i;
      p2[axis1] = i;
      p1[axis2] = -HALF;
      p2[axis2] = HALF;
      points.push(p1, p2);
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      gridGroup.add(new THREE.LineSegments(geo, gridMat));
    }
    for (let i = -HALF; i <= HALF; i++) {
      const points = [];
      const p1 = new THREE.Vector3();
      const p2 = new THREE.Vector3();
      p1[fixedAxis] = fixedVal;
      p2[fixedAxis] = fixedVal;
      p1[axis2] = i;
      p2[axis2] = i;
      p1[axis1] = -HALF;
      p2[axis1] = HALF;
      points.push(p1, p2);
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      gridGroup.add(new THREE.LineSegments(geo, gridMat));
    }
  }
  // Bottom and top faces
  addGridPlane('x', 'z', 'y', -HALF);
  addGridPlane('x', 'z', 'y', HALF);
  scene.add(gridGroup);

  // --- Snake meshes pool ---
  const snakeMeshes = [];
  const snakeGeo = new THREE.BoxGeometry(0.85, 0.85, 0.85);

  function getSnakeMaterial(index, total) {
    const t = total > 1 ? index / (total - 1) : 0;
    const hue = 0.5 + t * 0.3; // cyan -> purple
    const color = new THREE.Color().setHSL(hue, 1, 0.5);
    return new THREE.MeshStandardMaterial({
      color: color,
      emissive: color,
      emissiveIntensity: index === 0 ? 0.8 : 0.3,
      metalness: 0.3,
      roughness: 0.4,
      transparent: true,
      opacity: index === 0 ? 1.0 : 0.85
    });
  }

  function syncSnakeMeshes() {
    // Remove excess meshes
    while (snakeMeshes.length > snake.length) {
      const m = snakeMeshes.pop();
      scene.remove(m);
      m.geometry.dispose();
      m.material.dispose();
    }
    // Add or update meshes
    for (let i = 0; i < snake.length; i++) {
      const seg = snake[i];
      if (i >= snakeMeshes.length) {
        const mesh = new THREE.Mesh(snakeGeo, getSnakeMaterial(i, snake.length));
        scene.add(mesh);
        snakeMeshes.push(mesh);
      }
      const mesh = snakeMeshes[i];
      mesh.material.dispose();
      mesh.material = getSnakeMaterial(i, snake.length);
      mesh.position.set(seg.x, seg.y, seg.z);
    }
  }

  // --- Food ---
  let foodMesh = null;
  const foodGeo = new THREE.BoxGeometry(0.7, 0.7, 0.7);
  const foodEdgeGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(0.9, 0.9, 0.9));
  let foodGlow = null;

  function createFoodMesh(pos) {
    if (foodMesh) {
      scene.remove(foodMesh);
      foodMesh.material.dispose();
    }
    if (foodGlow) {
      scene.remove(foodGlow);
      foodGlow.material.dispose();
    }
    const mat = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      emissive: 0xff00ff,
      emissiveIntensity: 1.0,
      metalness: 0.5,
      roughness: 0.2,
      transparent: true,
      opacity: 0.9
    });
    foodMesh = new THREE.Mesh(foodGeo, mat);
    foodMesh.position.set(pos.x, pos.y, pos.z);
    scene.add(foodMesh);

    const edgeMat = new THREE.LineBasicMaterial({ color: 0xff66ff, transparent: true, opacity: 0.6 });
    foodGlow = new THREE.LineSegments(foodEdgeGeo, edgeMat);
    foodGlow.position.copy(foodMesh.position);
    scene.add(foodGlow);
  }

  function removeFoodMesh() {
    if (foodMesh) { scene.remove(foodMesh); foodMesh.material.dispose(); foodMesh = null; }
    if (foodGlow) { scene.remove(foodGlow); foodGlow.material.dispose(); foodGlow = null; }
  }

  // --- Game Logic ---
  function isOccupied(x, y, z) {
    return snake.some(s => s.x === x && s.y === y && s.z === z);
  }

  function spawnFood() {
    const empty = [];
    for (let x = -HALF; x <= HALF; x++) {
      for (let y = -HALF; y <= HALF; y++) {
        for (let z = -HALF; z <= HALF; z++) {
          if (!isOccupied(x, y, z)) empty.push({ x, y, z });
        }
      }
    }
    if (empty.length === 0) return null;
    return empty[Math.floor(Math.random() * empty.length)];
  }

  function initGame() {
    // Clear old meshes
    snakeMeshes.forEach(m => { scene.remove(m); m.material.dispose(); });
    snakeMeshes.length = 0;
    removeFoodMesh();

    // Init snake at center, 3 segments going -x
    snake = [
      { x: 1, y: 0, z: 0 },
      { x: 0, y: 0, z: 0 },
      { x: -1, y: 0, z: 0 }
    ];
    direction = { x: 1, y: 0, z: 0 };
    nextDirection = { x: 1, y: 0, z: 0 };
    score = 0;
    gameOver = false;

    food = spawnFood();
    if (food) createFoodMesh(food);

    syncSnakeMeshes();
    updateHUD();
  }

  function updateHUD() {
    scoreEl.textContent = score;
    lengthEl.textContent = snake.length;
    bestEl.textContent = best;
  }

  function tick() {
    if (!running || gameOver) return;

    direction = { ...nextDirection };

    const head = snake[0];
    const nx = head.x + direction.x;
    const ny = head.y + direction.y;
    const nz = head.z + direction.z;

    // Wall collision
    if (nx < -HALF || nx > HALF || ny < -HALF || ny > HALF || nz < -HALF || nz > HALF) {
      endGame();
      return;
    }

    // Self collision
    if (isOccupied(nx, ny, nz)) {
      endGame();
      return;
    }

    const newHead = { x: nx, y: ny, z: nz };
    snake.unshift(newHead);

    // Eat food?
    if (food && nx === food.x && ny === food.y && nz === food.z) {
      score += 10;
      removeFoodMesh();
      food = spawnFood();
      if (food) createFoodMesh(food);
    } else {
      snake.pop();
    }

    syncSnakeMeshes();
    updateHUD();
  }

  function endGame() {
    gameOver = true;
    running = false;
    if (score > best) {
      best = score;
      localStorage.setItem('snake3d_best', best.toString());
    }
    updateHUD();
    showOverlay('gameover');
  }

  function showOverlay(type) {
    overlay.classList.remove('hidden');
    if (type === 'gameover') {
      overlayContent.innerHTML = `
        <h1>Game Over</h1>
        <div class="final-score">${score}</div>
        <div class="final-label">最终得分</div>
        <div class="prompt">按 <span class="key">Space</span> 重新开始</div>
      `;
    }
  }

  // --- Input ---
  document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();

    if (key === ' ' || key === 'spacebar') {
      e.preventDefault();
      if (!running) {
        overlay.classList.add('hidden');
        initGame();
        running = true;
        lastTick = performance.now();
      }
      return;
    }

    if (!running) return;

    const d = direction;
    switch (key) {
      case 'w': if (d.z !== 1)  nextDirection = { x: 0, y: 0, z: -1 }; break;  // forward (-Z)
      case 's': if (d.z !== -1) nextDirection = { x: 0, y: 0, z: 1 };  break;  // backward (+Z)
      case 'a': if (d.x !== 1)  nextDirection = { x: -1, y: 0, z: 0 }; break;  // left (-X)
      case 'd': if (d.x !== -1) nextDirection = { x: 1, y: 0, z: 0 };  break;  // right (+X)
      case 'e': if (d.y !== -1) nextDirection = { x: 0, y: 1, z: 0 };  break;  // up (+Y)
      case 'q': if (d.y !== 1)  nextDirection = { x: 0, y: -1, z: 0 }; break;  // down (-Y)
    }
  });

  // --- Camera orbit ---
  let cameraAngle = Math.PI / 4;
  let cameraRadius = 28;
  let cameraHeight = 18;
  let isDragging = false;
  let lastMouseX = 0;

  renderer.domElement.addEventListener('mousedown', (e) => {
    isDragging = true;
    lastMouseX = e.clientX;
  });
  window.addEventListener('mouseup', () => { isDragging = false; });
  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - lastMouseX;
    lastMouseX = e.clientX;
    cameraAngle += dx * 0.005;
  });
  renderer.domElement.addEventListener('wheel', (e) => {
    e.preventDefault();
    cameraRadius = Math.max(15, Math.min(50, cameraRadius + e.deltaY * 0.02));
  }, { passive: false });

  // --- Resize ---
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // --- Animation Loop ---
  const clock = new THREE.Clock();

  function animate(now) {
    requestAnimationFrame(animate);

    const elapsed = clock.getElapsedTime();

    // Game tick
    if (running && !gameOver) {
      if (now - lastTick >= TICK_MS) {
        tick();
        lastTick = now;
      }
    }

    // Rotate food
    if (foodMesh) {
      foodMesh.rotation.x = elapsed * 2;
      foodMesh.rotation.y = elapsed * 3;
      const pulse = 0.8 + Math.sin(elapsed * 5) * 0.2;
      foodMesh.material.emissiveIntensity = pulse;
      if (foodGlow) {
        foodGlow.rotation.copy(foodMesh.rotation);
        foodGlow.material.opacity = 0.3 + Math.sin(elapsed * 5) * 0.3;
      }
    }

    // Rotate snake head
    if (snakeMeshes.length > 0) {
      snakeMeshes[0].rotation.x = elapsed * 1.5;
      snakeMeshes[0].rotation.y = elapsed * 2;
    }

    // Animate snake body with wave
    for (let i = 1; i < snakeMeshes.length; i++) {
      const wave = Math.sin(elapsed * 3 + i * 0.5) * 0.1;
      snakeMeshes[i].rotation.x = wave;
      snakeMeshes[i].rotation.y = wave * 0.5;
    }

    // Arena pulse
    arenaMat.opacity = 0.1 + Math.sin(elapsed * 2) * 0.05;

    // Camera orbit
    camera.position.x = Math.cos(cameraAngle) * cameraRadius;
    camera.position.z = Math.sin(cameraAngle) * cameraRadius;
    camera.position.y = cameraHeight;
    camera.lookAt(0, 0, 0);

    // Move lights
    pointLight1.position.x = Math.cos(elapsed * 0.5) * 12;
    pointLight1.position.z = Math.sin(elapsed * 0.5) * 12;
    pointLight2.position.x = Math.cos(elapsed * 0.3 + 2) * 10;
    pointLight2.position.z = Math.sin(elapsed * 0.3 + 2) * 10;

    renderer.render(scene, camera);
  }

  // --- Start ---
  initGame();
  syncSnakeMeshes();
  animate(performance.now());

})();
</script>
</body>
</html>
